0 info it worked if it ends with ok
1 verbose cli [ 'C:\\Program Files\\nodejs\\\\node.exe',
1 verbose cli   'C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',
1 verbose cli   'publish' ]
2 info using npm@1.4.27
3 info using node@v0.10.17
4 verbose node symlink C:\Program Files\nodejs\\node.exe
5 verbose publish [ '.' ]
6 verbose cache add [ '.', null ]
7 verbose cache add name=undefined spec="." args=[".",null]
8 verbose parsed url { protocol: null,
8 verbose parsed url   slashes: null,
8 verbose parsed url   auth: null,
8 verbose parsed url   host: null,
8 verbose parsed url   port: null,
8 verbose parsed url   hostname: null,
8 verbose parsed url   hash: null,
8 verbose parsed url   search: null,
8 verbose parsed url   query: null,
8 verbose parsed url   pathname: '.',
8 verbose parsed url   path: '.',
8 verbose parsed url   href: '.' }
9 silly lockFile 3a52ce78- .
10 verbose lock . C:\Users\Sam\AppData\Roaming\npm-cache\3a52ce78-.lock
11 verbose tar pack [ 'C:\\Users\\Sam\\AppData\\Roaming\\npm-cache\\f_\\0.0.6\\package.tgz',
11 verbose tar pack   '.' ]
12 verbose tarball C:\Users\Sam\AppData\Roaming\npm-cache\f_\0.0.6\package.tgz
13 verbose folder .
14 info prepublish f_@0.0.6
15 silly lockFile 1f1177db-tar tar://.
16 verbose lock tar://. C:\Users\Sam\AppData\Roaming\npm-cache\1f1177db-tar.lock
17 silly lockFile e5f2382b-ng-npm-cache-f-0-0-6-package-tgz tar://C:\Users\Sam\AppData\Roaming\npm-cache\f_\0.0.6\package.tgz
18 verbose lock tar://C:\Users\Sam\AppData\Roaming\npm-cache\f_\0.0.6\package.tgz C:\Users\Sam\AppData\Roaming\npm-cache\e5f2382b-ng-npm-cache-f-0-0-6-package-tgz.lock
19 silly lockFile 1f1177db-tar tar://.
20 silly lockFile 1f1177db-tar tar://.
21 silly lockFile e5f2382b-ng-npm-cache-f-0-0-6-package-tgz tar://C:\Users\Sam\AppData\Roaming\npm-cache\f_\0.0.6\package.tgz
22 silly lockFile e5f2382b-ng-npm-cache-f-0-0-6-package-tgz tar://C:\Users\Sam\AppData\Roaming\npm-cache\f_\0.0.6\package.tgz
23 silly lockFile 8b2bb06e-oaming-npm-cache-f-0-0-6-package C:\Users\Sam\AppData\Roaming\npm-cache\f_\0.0.6\package
24 verbose lock C:\Users\Sam\AppData\Roaming\npm-cache\f_\0.0.6\package C:\Users\Sam\AppData\Roaming\npm-cache\8b2bb06e-oaming-npm-cache-f-0-0-6-package.lock
25 silly lockFile 8b2bb06e-oaming-npm-cache-f-0-0-6-package C:\Users\Sam\AppData\Roaming\npm-cache\f_\0.0.6\package
26 silly lockFile 8b2bb06e-oaming-npm-cache-f-0-0-6-package C:\Users\Sam\AppData\Roaming\npm-cache\f_\0.0.6\package
27 silly lockFile 3a52ce78- .
28 silly lockFile 3a52ce78- .
29 silly publish { name: 'f_',
29 silly publish   version: '0.0.6',
29 silly publish   description: 'Asynchronous Node.js made easy.',
29 silly publish   scripts:
29 silly publish    { test: 'node node_modules/istanbul/lib/cli.js cover node_modules/mocha/bin/_mocha "./test/mocha/*.js" && npm run coveralls',
29 silly publish      localTest: 'node node_modules/istanbul/lib/cli.js cover node_modules/mocha/bin/_mocha "./test/mocha/*.js"',
29 silly publish      coveralls: 'node node_modules/coveralls/bin/coveralls.js < coverage/lcov.info' },
29 silly publish   engines: { node: '>=0.8' },
29 silly publish   dependencies: { ezlog: '0.0.12', opensoars_cls: '0.0.8' },
29 silly publish   devDependencies: { mocha: '*', istanbul: '*', coveralls: '*' },
29 silly publish   repository: { type: 'git', url: 'https%://github.com/opensoars/f_' },
29 silly publish   readmeFilename: 'README.md',
29 silly publish   readme: 'f_ (f.low, flow)\r\n==================\r\n\r\n\r\n[![Build Status](https://img.shields.io/travis/opensoars/f_.svg?style=flat)](https://travis-ci.org/opensoars/f_)\r\n[![Coverage Status](https://img.shields.io/coveralls/opensoars/f_.svg?style=flat)](https://coveralls.io/r/opensoars/f_)\r\n[![Dependency Status](https://david-dm.org/opensoars/f_.svg?style=flat)](https://david-dm.org/opensoars/f_)\r\n[![Development Dependency Status](https://david-dm.org/opensoars/f_/dev-status.svg?style=flat)](https://david-dm.org/opensoars/f_#info=devDependencies&view=table)\r\n\r\n\r\nAsynchronous Node.js made easy and fun!\r\n\r\n\r\n---\r\n\r\n\r\n### Dependencies\r\n* [cls](https://github.com/opensoars/cls)\r\n* [ezlog](https://github.com/opensoars/ezlog)\r\n\r\n\r\n### Install\r\n`npm install f_`\r\n\r\n### Examples\r\nClick [here](https://github.com/opensoars/f_/tree/master/doc/examples) to browse f_ examples. Altogether they will cover everything f_ has to offer.\r\n\r\n### Run tests and get coverage (lcov) report\r\n`npm run localTest`\r\n\r\n\r\n### Basic usage\r\n```js\r\nvar f_ = require(\'f_\');\r\n\r\n// Augment a task list class.\r\nTaskList = f_.augment(require(\'TaskList.js\'), {\r\n  functionFlow: [\'firstMethod\', \'secondMethod\', \'lastMethod\']\r\n});\r\n\r\n// Setup a task list instance.\r\nvar taskListInstance = f_.setup( new TaskList() );\r\n\r\n// Call task list it\'s self written start method.\r\n// taskListInstance.start(); will call f_next();\r\ntaskListInstance.start();\r\n```\r\n\r\n\r\n---\r\n\r\n\r\n### Todo\r\n\r\n* Write more [examples](https://github.com/opensoars/f_/tree/master/doc/examples)\r\n* Write memory tests using [raminfo](https://github.com/opensoars/raminfo)\r\n* Complete [documentation](https://github.com/opensoars/f_#documentation-outdated)\r\n\r\n### Time schedule (from the 10th of September 2014)\r\n\r\n* 1.5/2 weeks (will result in pre-alpha release)\r\n  - Further brainstorming\r\n  - Expand documentation all features\r\n  - Complete features\r\n  - Release of a working prototype\r\n\r\n* 2.5/3 weeks (will result in alpha release)\r\n  - Complete product development\r\n  - Documentation of development process\r\n\r\n* 2.5/3 weeks (will result in beta release)\r\n  - Testing\r\n  - Fixing unexpected behaviour\r\n  - Complete documentation\r\n\r\n\r\n---\r\n\r\n\r\n## Future documentation content\r\n\r\n1. Title\r\n2. Badges\r\n3. One liner\r\n4. Dependencies\r\n5. Install\r\n6. Use\r\n7. Documentation\r\n  1. Problem\r\n  2. Solution\r\n  3. Introduction\r\n    * Async and sync\r\n    * Small examples\r\n      * Not wanted\r\n      * Wanted\r\n  4. Full example covering complete usage (API)\r\n  5. Individual components\r\n8. Example usage\r\n\r\n\r\n---\r\n\r\n\r\n## Documentation (outdated)\r\n\r\n\r\n### Problem to be solved\r\nWriting asynchronous, maintainable, modular and loosely coupled programs in Node.js without some help from a library/framework is hard (if you do not want to end up with \'christmas tree\' code which will get you into (callback) hell).\r\n\r\n\r\n### How is `f_` going to solve this problem?\r\nAllow programmers to use a Node.js module with a simple API which will make separation of concerns (which results in loosely coupled programs), modular and asynchronous programming a breeze.\r\n\r\n\r\n### Introduction\r\nEvery (large) Node.js program has lots of asynchronous tasks such as:\r\n* HTTP requests\r\n* Complex equation solving\r\n* Audio/video compressing\r\n\r\nOfcourse small tasks in larger asynchronous tasks will be synchronous. Some examples are:\r\n* Concatenating a string\r\n* solving simple equations\r\n* Declaring variables\r\n\r\nWhen we look at the two lists above, we can categorize computational tasks into two separate groups:\r\n\r\n1. Asynchronous (either simple and quick or complex and long lasting)\r\n2. Synchronous (only simple and quick)\r\n\r\n\r\n<!---\r\nLET\'S FIX THIS SHIT BELOW!\r\nLET\'S FIX THIS SHIT BELOW!\r\nLET\'S FIX THIS SHIT BELOW!\r\n-->\r\n\r\n### API\r\nEverything `f_` offers will be used in the code example below. We will be using a class based approach (plain object not recommended). Since we will be initiating a lot of instances, so we will make use of JavaScript it\'s prototypal inheritance pattern.\r\n```js\r\n\r\n// EDIT THIS WITH NEW API / PROTO ASSIGMENT\r\n\r\nvar f_ = require(\'f_\');\r\n\r\n/** Class based TaskList.\r\n * All methods are written in this class\r\n * @class TaskList      Class which holds all methods, used to set data\r\n *                      on initialization\r\n * @arg o.url {string}  Url to grab source code from\r\n */\r\nvar TaskList = function TaskList (o){\r\n  o = o || {};\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Create an empty namespace object to hold our proto(type) methods\r\n * Which will be assigned to the TaskList its prototype object\r\n */\r\nvar proto = {};\r\n\r\n/**\r\n * @method start  Check if requirements are met\r\n */\r\nproto.start = function (){\r\n\r\n};\r\n\r\n\r\n/**\r\n * @method getSource          Gets a website source code\r\n * @req    url {string}  Url to grab source code from\r\n * @data   d.source {string}  Website it\'s source code\r\n */\r\nproto.getSource = function (){\r\n\r\n};\r\n\r\n\r\n/**\r\n * @method writeSource        Writes a source code on HD\r\n * @req    d.source {string}  Website it\'s source page\r\n */\r\nproto.writeSource = function (){\r\n\r\n};\r\n\r\n\r\n/**\r\n * @method notify  Log what happened in the previous methods\r\n */\r\nproto.notify = function (){\r\n\r\n};\r\n\r\n\r\n/**\r\n * Adding data to Class proto object, it will be same with every instance.\r\n * No need to add it to our shared data object namespace, which could be reset.\r\n * Also using the prototype object, we only assign it once.\r\n */\r\nproto.writeDir = \'./sourceCodes\';\r\n\r\n\r\n/**\r\n * Assign methods from proto object to our TaskList its actual\r\n * prototype object.\r\n * Ofcourse, make sure our proto object has all properties we want it\r\n * to have before we assign it!\r\n */\r\nTaskList.prototype = proto;\r\n\r\n\r\n/** f_config object\r\n * In this object we can tell f_ what to do.\r\n * It can be quite detailed. But only a few properties are actualy\r\n * required for f_ to work\r\n */\r\nvar f_config = {\r\n\r\n  // Function order f_ uses to call methods\r\n  // REQUIRED to atleast have one element!\r\n  functionFlow: [\'getSource\', \'writeSource\', \'notify\'],\r\n\r\n  // Name given to the errors array\r\n  // default: errs\r\n  errorArray: \'errs\', \r\n\r\n  // Do we want a data reset when we use \'retryAll\'. Can be changed later on\r\n  // in our code ofcourse!\r\n  // Default: false\r\n  resetOnRetryAll: true,\r\n\r\n  // Object in which we store our shared data.\r\n  // Default: \'d\'\r\n  dataNamespace: \'d\',\r\n\r\n  // Data namespace properties to keep on reset.\r\n  keepOnReset: [\'testNamespace\'],\r\n\r\n  // How many times f_ will retry the whole task list\r\n  // Default: 10\r\n  maxRetriesAll: 15,\r\n\r\n  // How many times f_ will retry a single method\r\n  // Default: 10\r\n  maxMethodRetries: 5,\r\n\r\n  // Specific methods will be retried specified times.\r\n  // Will override maxMethodRetries\r\n  maxMethodRetriesByName: {\r\n    getSource: 10,\r\n    writeSource: 5\r\n  },\r\n\r\n  // What to log\r\n  // start:   If first method in functionFlow is called\r\n  // next:    A method is called, we log the method name.\r\n  // retry:   A retry occurs, log everything known about it.\r\n  // error:   An error gets pushed to errs array, log err description and\r\n  //          origional error object.\r\n  // abort:   f_ aborts a task list, log error stack and method\r\n  //          which caused error.\r\n  // finish:  Log when tasks is complete and time taken\r\n  // all:     Log \'everything\' f_ does, all above triggers will be true.\r\n  // silent:  Log nothing at all.\r\n  // Default: [\'all\']\r\n  toLog: [\'next\', \'retry\']\r\n\r\n};\r\n\r\n// \'augment\' method takes two arguments: object/class to augment and\r\n// a config object.\r\nTaskList = f_.augment(TaskList, f_config);\r\n\r\n// Initiate 100 instances \r\nfor(var i = 0; i < 100; i+=1){\r\n  // Provide data which will be set to the instance it\'s properties.\r\n  var tasksInstance = new TaskList();\r\n  tasksInstance.start();\r\n\r\n  if(tasksInstance.errs.length === 0)\r\n    console.log(\'Ok, everything has started correctly, task:\', i);\r\n  else\r\n    console.log(\'Errors at start, probably we do not want to continue w/\', i);\r\n}\r\n```\r\n\r\n### In depth look at the way `f_` DOESN\'T work.\r\n\r\nWhen we are looking at the way Node handles asynchronous computation, we are looking at the simple to grasp and understand, yet powerful practice of callbacks. Whilst this practice may be simple, code management, separation of concerns and loose coupling can be diffucult to achieve. This is due to something called \'callback hell\'. Which will result in \'christmas tree code\'. An (ugly) example below:\r\n```js\r\n/**\r\n * Simple task which will first GET google.com source code, write it to a HTML\r\n * file. When those two tasks are complete it will GET google.nl source code\r\n * and also write that to a HTML file. Written the most ugly way possible,\r\n * we\'re not even using named function declaration above the the async logic.\r\n */\r\nhttp.get(\'http://www.google.com\', function (googleRes){\r\n  \r\n  var googleSource = \'\';\r\n  \r\n  googleRes.on(\'data\', function (googleChunk){\r\n    googleSource = googleSource + googleChunk;\r\n  });\r\n  \r\n  googleRes.on(\'end\', function (){\r\n    fs.writeFile(\'googleSource.html\', googleSource, function (googleWriteErr){\r\n      if(googleWriteErr) return console.log(googleWriteErr);\r\n      \r\n      http.get(\'http://www.youtube.com\', function (ytRes){\r\n        \r\n        var ytSource = \'\';\r\n        \r\n        ytRes.on(\'data\', function (ytChunk){\r\n          ytSource = ytSource + ytChunk;\r\n        });\r\n        \r\n        ytRes.on(\'end\', function (){\r\n          fs.writeFile(\'ytSource.html\', ytSource, function (ytWriteErr){\r\n            if(ytWriteErr) return console.log(ytWriteErr);\r\n            \r\n            return console.log(\'Tasks complete!\');\r\n          });\r\n        });\r\n      });\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n\r\n\r\nAs you can see, this code hard to read, write and maintain. We\'re not even taking error handling and dependecy management in account here... Which will make it even harder to read, write and maintain.\r\n\r\n### In depth look at the way `f_` DOES work.\r\n\r\nLet\'s take a look at the way I want to write this simple task!\r\n\r\n```js\r\n/**\r\n * Please note we\'re still not using a good error handling mehtod,\r\n * the same logic as the ugly example is used.\r\n */\r\n\r\nproto.getGoogle = function (){\r\n  var self = this;\r\n\r\n  http.get(\'http://www.google.com\', function (res){\r\n\r\n    var source = \'\';\r\n    res.on(\'data\', function (chunk){ source = source + chunk; });\r\n\r\n    res.on(\'end\', function (){\r\n      // Using the d object namespace to store data we\r\n      // need to use in other/later function scopes\r\n      self.d.googleSource = source;\r\n\r\n      // return statement isn\'t necessary, using it to show we\'re\r\n      // done with this task.\r\n      return self.next();\r\n    });\r\n\r\n  });\r\n};\r\n\r\n\r\nproto.writeGoogle = function (){\r\n  var self = this,\r\n      googleSource = self.d.googleSource;\r\n\r\n  fs.writeFile(\'googleSource.html\', googleSource, function (err){\r\n    if(err) return console.log(err);\r\n    return self.next();\r\n  });\r\n\r\n};\r\n\r\nproto.getYt = function (){\r\n  var self = this;\r\n\r\n  http.get(\'http://www.youtube.com\', function (res){\r\n\r\n    var source = \'\';\r\n    res.on(\'data\', function (chunk){ source = source + chunk; });\r\n\r\n    res.on(\'end\', function (){\r\n      self.d.ytSource = source;\r\n      return self.next();\r\n    });\r\n\r\n  });\r\n};\r\n\r\nproto.writeYt = function (){\r\n  var self = this,\r\n      ytSource = self.d.ytSource;\r\n\r\n  fs.writeFile(\'ytSource.html\', ytSource, function (err){\r\n    if(err) return console.log(err);\r\n\r\n    // Using next when there are no more tasks will result in a low\r\n    // level f_ API \'f_.finish\' method call. Clearing up used memory, etc..\r\n    return self.next();\r\n  });\r\n\r\n};\r\n```\r\n\r\nYes, we did it; separation of concerns and loose coupling! We could even modularize (litteraly) it, since all those smaller asynchronous tasks could be single modules, if wanted they can even be put in single files. In this case I would keep it in a single file, since all tasks are small and easy to read/maintain. Even though we are using more lines of code.\r\n\r\nSo far we can say that `f_` will allow us to program in a modularized way. Which is great already! Well, more greatness is coming your way!\r\n\r\nNow let\'s take a look at the way we will be handling errors (using a piece of the previous example):\r\n```js\r\n/**\r\n * In this piece of code, we will catch error messages so we can display\r\n * the complete error stack when the task is aborted, or when we look up\r\n * the f_ \'errs\' array filled with error objects.\r\n */\r\nproto.getGoogle = function (){\r\n  var self = this;\r\n\r\n  http.get(\'http://www.google.com\', function (res){\r\n\r\n    var source = \'\';\r\n    res.on(\'data\', function (chunk){ source = source + chunk; });\r\n\r\n    res.on(\'end\', function (){\r\n      self.d.googleSource = source;\r\n      return self.next();\r\n    });\r\n\r\n  }).on(\'error\', function (err){\r\n    // We provide a custom error message string and the original err object\r\n    return self.addErr(\'http.get error\', err);\r\n  });\r\n};\r\n\r\n\r\nproto.writeGoogle = function (){\r\n  var self = this,\r\n      googleSource = self.d.googleSource;\r\n\r\n  fs.writeFile(\'googleSource.html\', googleSource, function (err){\r\n    // Same as with http.get\r\n    if(err) return self.addErr(\'fs.writeFile error\', err);\r\n\r\n    return self.next();\r\n  });\r\n\r\n};\r\n```\r\n\r\nSo we\'ve got a way to create an error stack, now we need a way to do something when an error occurs. This could ofcourse be done traditionally with \r\n`on(\'error\')` event listeners. The problem with that is, we cannot directly \'throw\' in a retry when something fails. Writing `on(\'error\')` listeners everytime is tedious. Something we try to remove from programming Node programs (don\'t forget you CAN still use them!). So with `f_` we can do it directly from a piece of code that causes an error. Take a look at this example:\r\n```js\r\n// Immediately retry this asynchronous part of a larger task list\r\nproto.getGoogle = function (){\r\n  var self = this;\r\n\r\n  http.get(\'http://www.google.com\', function (res){\r\n    // ...\r\n  }).on(\'error\', function (err){\r\n    // With this function call we still add errors to the stack,\r\n    // but immediately retry the current function\r\n    return self.retryThis(\'http.get error\', err);\r\n  });\r\n};\r\n```\r\n\r\nLet\'s say we use the source code received from Google.com in a later function but the `GET` request fails the first time, we want to make sure every piece of data we stored is removed from our RAM. We need a way to make `f_` know what data to remove from the data namespace object. We can do this by manualy providing `f_` with objects.\r\n\r\n```js\r\nproto.getGoogle = function (){\r\n  var self = this;\r\n\r\n  http.get(\'http://www.google.com\', function (res){\r\n    self.d.googleSource = \'\';\r\n    res.on(\'data\', function (chunk){\r\n      self.d.googleSource = self.d.googleSource + chunk;\r\n    });\r\n\r\n    res.on(\'end\', function (){\r\n      return self.next();\r\n    });\r\n\r\n  }).on(\'error\', function (err){\r\n    // Providing \'dataToReset\' with an object, f_ will reset properties\r\n    // with given values when we use the retryThis method\r\n    self.dataToReset = { googleSource: \'\' };\r\n\r\n    // The following syntax is also supported, this way we can reset\r\n    // objects deeper in the data namespace object\r\n    self.dataToReset = { \'dataObjectNamespace.someProperty\': {} }\r\n\r\n    return self.retryThis(\'http.get error\', err);\r\n  });\r\n};\r\n```\r\n\r\nThis way we can ensure data is removed, ofcourse you could also override properties. But this could result in unwanted and hard to find corrupted data. There also is way to make sure EVERY piece of data is removed from our data object namespace: `self.resetAllData();`\r\n\r\nSo far we\'ve talked about the data object namespace quite a lot. Let\'s take a closer look at how it works. We used the `d` namespace in our examples. This is just a plain JS object. With `f_` we can set our data object like this: `self.setDataObject(\'d\')` or like this: `self.d = {};`. If you want more namespaces, simply do the following:\r\n`self.d.newNameSpace = {}`. \r\nPlease note that when you use the `self.resetAllData();` all namespaces in the top level namespace will be cleared. In case this is unwanted there is a way to let `f_` know we want to keep certain properties in our main namespace: \r\n`self.keepOnReset = [\'newNameSpace\'];`. There might even be cases where you don\'t want to reset anything at all, use: `self.resetOnRetry = false;`\r\n\r\n\r\n* DISCUSS: `retryAll(optErrMsgString, optErrObj);`\r\n* DISCUSS: `retryThis(optErrMsgString, optErrObj);`\r\n\r\n\r\n\r\nLet\'s put everything in a part of a \'real world\' code example:\r\n```js\r\n/**\r\n * When using f_, I tend to use \'start\' as a function which will check\r\n * for dependencies and as a setup.\r\n */\r\nproto.start = function (){\r\n  // ... dependency verification could/should be here ...\r\n\r\n  self.setDataObject(\'d\');\r\n  // ^ Could also be written like this: self.d = {};\r\n  // might result in overriding data, since setDataObject won\'t\r\n  // change the property if it\'s set already\r\n\r\n  self.d.newNameSpace = {};       // this one will be kept\r\n  self.d.someOtherNamespace = {}; // this one will be removed\r\n\r\n  // Which properties to keep when we use a reset\r\n  self.keepOnReset = [\'newNameSpace\'];\r\n\r\n  // Do we actualy want a data reset? In this case; true!\r\n  self.resetOnRetry = true;\r\n\r\n};\r\n\r\nproto.getGoogle = function (){\r\n  var self = this;\r\n\r\n  self.d.googleSource = \'\';\r\n  res.on(\'data\', function (chunk){\r\n    self.d.googleSource = self.d.googleSource + chunk;\r\n  });\r\n\r\n  res.on(\'end\', function (){\r\n    return self.next();\r\n  }).on(\'error\', function (err){\r\n    // With this function call we still add errors to the stack,\r\n    // but immediately retry the current function\r\n    return self.retryThis(\'http.get error\', err);\r\n  });\r\n\r\n};\r\n\r\nproto.writeGoogle = function (){\r\n  // Check if the required data is present. In case it isn\'t,\r\n  // we retry our whole task list\r\n};\r\n\r\n```',
29 silly publish   gitHead: 'e7f22220a1d44986c8538faab63d2a2f6ab72296',
29 silly publish   _id: 'f_@0.0.6',
29 silly publish   _shasum: '376abcfea4af50c0be1b8a443c8103024c062be0',
29 silly publish   _from: '.' }
30 verbose request where is /f_
31 verbose request registry https://registry.npmjs.org/
32 verbose request id 0ebf91f851ee78d1
33 verbose url raw /f_
34 verbose url resolving [ 'https://registry.npmjs.org/', './f_' ]
35 verbose url resolved https://registry.npmjs.org/f_
36 verbose request where is https://registry.npmjs.org/f_
37 info trying registry request attempt 1 at 14:20:29
38 http PUT https://registry.npmjs.org/f_
39 http 403 https://registry.npmjs.org/f_
40 verbose headers { date: 'Thu, 09 Oct 2014 12:20:27 GMT',
40 verbose headers   server: 'CouchDB/1.5.0 (Erlang OTP/R16B03)',
40 verbose headers   'content-type': 'application/json',
40 verbose headers   'cache-control': 'max-age=60',
40 verbose headers   'content-length': '27078',
40 verbose headers   'accept-ranges': 'bytes',
40 verbose headers   via: '1.1 varnish',
40 verbose headers   'x-served-by': 'cache-ams4127-AMS',
40 verbose headers   'x-cache': 'MISS',
40 verbose headers   'x-cache-hits': '0',
40 verbose headers   'x-timer': 'S1412857225.951543,VS0,VE1360',
40 verbose headers   'keep-alive': 'timeout=10, max=50',
40 verbose headers   connection: 'Keep-Alive' }
41 error publish Failed PUT 403
42 error Error: forbidden cannot modify pre-existing version: 0.0.6
42 error old={"name":"f_","version":"0.0.6","description":"Asynchronous Node.js made easy.","scripts":{"test":"node node_modules/istanbul/lib/cli.js cover node_modules/mocha/bin/_mocha \"./test/mocha/*.js\" && npm run coveralls","localTest":"node node_modules/istanbul/lib/cli.js cover node_modules/mocha/bin/_mocha \"./test/mocha/*.js\"","coveralls":"node node_modules/coveralls/bin/coveralls.js < coverage/lcov.info"},"engines":{"node":">=0.8"},"dependencies":{"ezlog":"0.0.11","opensoars_cls":"0.0.7"},"devDependencies":{"mocha":"*","istanbul":"*","coveralls":"*"},"repository":{"type":"git","url":"https://github.com/opensoars/f_"},"gitHead":"cff6dfe714a3a23785187be5bebce39e71843255","bugs":{"url":"https://github.com/opensoars/f_/issues"},"homepage":"https://github.com/opensoars/f_","_id":"f_@0.0.6","_shasum":"3d6b81d90372a0e79fc060df9ff0da9f3822c475","_from":".","_npmVersion":"1.4.27","_npmUser":{"name":"opensoars","email":"sam.dev@outlook.com"},"maintainers":[{"name":"opensoars","email":"sam.dev@outlook.com"}],"dist":{"shasum":"3d6b81d90372a0e79fc060df9ff0da9f3822c475","tarball":"http://registry.npmjs.org/f_/-/f_-0.0.6.tgz"}}
42 error new={"name":"f_","version":"0.0.6","description":"Asynchronous Node.js made easy.","scripts":{"test":"node node_modules/istanbul/lib/cli.js cover node_modules/mocha/bin/_mocha \"./test/mocha/*.js\" && npm run coveralls","localTest":"node node_modules/istanbul/lib/cli.js cover node_modules/mocha/bin/_mocha \"./test/mocha/*.js\"","coveralls":"node node_modules/coveralls/bin/coveralls.js < coverage/lcov.info"},"engines":{"node":">=0.8"},"dependencies":{"ezlog":"0.0.12","opensoars_cls":"0.0.8"},"devDependencies":{"mocha":"*","istanbul":"*","coveralls":"*"},"repository":{"type":"git","url":"https%://github.com/opensoars/f_"},"readmeFilename":"README.md","readme":"f_ (f.low, flow)\u000d\u000a==================\u000d\u000a\u000d\u000a\u000d\u000a[![Build Status](https://img.shields.io/travis/opensoars/f_.svg?style=flat)](https://travis-ci.org/opensoars/f_)\u000d\u000a[![Coverage Status](https://img.shields.io/coveralls/opensoars/f_.svg?style=flat)](https://coveralls.io/r/opensoars/f_)\u000d\u000a[![Dependency Status](https://david-dm.org/opensoars/f_.svg?style=flat)](https://david-dm.org/opensoars/f_)\u000d\u000a[![Development Dependency Status](https://david-dm.org/opensoars/f_/dev-status.svg?style=flat)](https://david-dm.org/opensoars/f_#info=devDependencies&view=table)\u000d\u000a\u000d\u000a\u000d\u000aAsynchronous Node.js made easy and fun!\u000d\u000a\u000d\u000a\u000d\u000a---\u000d\u000a\u000d\u000a\u000d\u000a### Dependencies\u000d\u000a* [cls](https://github.com/opensoars/cls)\u000d\u000a* [ezlog](https://github.com/opensoars/ezlog)\u000d\u000a\u000d\u000a\u000d\u000a### Install\u000d\u000a`npm install f_`\u000d\u000a\u000d\u000a### Examples\u000d\u000aClick [here](https://github.com/opensoars/f_/tree/master/doc/examples) to browse f_ examples. Altogether they will cover everything f_ has to offer.\u000d\u000a\u000d\u000a### Run tests and get coverage (lcov) report\u000d\u000a`npm run localTest`\u000d\u000a\u000d\u000a\u000d\u000a### Basic usage\u000d\u000a```js\u000d\u000avar f_ = require('f_');\u000d\u000a\u000d\u000a// Augment a task list class.\u000d\u000aTaskList = f_.augment(require('TaskList.js'), {\u000d\u000a  functionFlow: ['firstMethod', 'secondMethod', 'lastMethod']\u000d\u000a});\u000d\u000a\u000d\u000a// Setup a task list instance.\u000d\u000avar taskListInstance = f_.setup( new TaskList() );\u000d\u000a\u000d\u000a// Call task list it's self written start method.\u000d\u000a// taskListInstance.start(); will call f_next();\u000d\u000ataskListInstance.start();\u000d\u000a```\u000d\u000a\u000d\u000a\u000d\u000a---\u000d\u000a\u000d\u000a\u000d\u000a### Todo\u000d\u000a\u000d\u000a* Write more [examples](https://github.com/opensoars/f_/tree/master/doc/examples)\u000d\u000a* Write memory tests using [raminfo](https://github.com/opensoars/raminfo)\u000d\u000a* Complete [documentation](https://github.com/opensoars/f_#documentation-outdated)\u000d\u000a\u000d\u000a### Time schedule (from the 10th of September 2014)\u000d\u000a\u000d\u000a* 1.5/2 weeks (will result in pre-alpha release)\u000d\u000a  - Further brainstorming\u000d\u000a  - Expand documentation all features\u000d\u000a  - Complete features\u000d\u000a  - Release of a working prototype\u000d\u000a\u000d\u000a* 2.5/3 weeks (will result in alpha release)\u000d\u000a  - Complete product development\u000d\u000a  - Documentation of development process\u000d\u000a\u000d\u000a* 2.5/3 weeks (will result in beta release)\u000d\u000a  - Testing\u000d\u000a  - Fixing unexpected behaviour\u000d\u000a  - Complete documentation\u000d\u000a\u000d\u000a\u000d\u000a---\u000d\u000a\u000d\u000a\u000d\u000a## Future documentation content\u000d\u000a\u000d\u000a1. Title\u000d\u000a2. Badges\u000d\u000a3. One liner\u000d\u000a4. Dependencies\u000d\u000a5. Install\u000d\u000a6. Use\u000d\u000a7. Documentation\u000d\u000a  1. Problem\u000d\u000a  2. Solution\u000d\u000a  3. Introduction\u000d\u000a    * Async and sync\u000d\u000a    * Small examples\u000d\u000a      * Not wanted\u000d\u000a      * Wanted\u000d\u000a  4. Full example covering complete usage (API)\u000d\u000a  5. Individual components\u000d\u000a8. Example usage\u000d\u000a\u000d\u000a\u000d\u000a---\u000d\u000a\u000d\u000a\u000d\u000a## Documentation (outdated)\u000d\u000a\u000d\u000a\u000d\u000a### Problem to be solved\u000d\u000aWriting asynchronous, maintainable, modular and loosely coupled programs in Node.js without some help from a library/framework is hard (if you do not want to end up with 'christmas tree' code which will get you into (callback) hell).\u000d\u000a\u000d\u000a\u000d\u000a### How is `f_` going to solve this problem?\u000d\u000aAllow programmers to use a Node.js module with a simple API which will make separation of concerns (which results in loosely coupled programs), modular and asynchronous programming a breeze.\u000d\u000a\u000d\u000a\u000d\u000a### Introduction\u000d\u000aEvery (large) Node.js program has lots of asynchronous tasks such as:\u000d\u000a* HTTP requests\u000d\u000a* Complex equation solving\u000d\u000a* Audio/video compressing\u000d\u000a\u000d\u000aOfcourse small tasks in larger asynchronous tasks will be synchronous. Some examples are:\u000d\u000a* Concatenating a string\u000d\u000a* solving simple equations\u000d\u000a* Declaring variables\u000d\u000a\u000d\u000aWhen we look at the two lists above, we can categorize computational tasks into two separate groups:\u000d\u000a\u000d\u000a1. Asynchronous (either simple and quick or complex and long lasting)\u000d\u000a2. Synchronous (only simple and quick)\u000d\u000a\u000d\u000a\u000d\u000a<!---\u000d\u000aLET'S FIX THIS SHIT BELOW!\u000d\u000aLET'S FIX THIS SHIT BELOW!\u000d\u000aLET'S FIX THIS SHIT BELOW!\u000d\u000a-->\u000d\u000a\u000d\u000a### API\u000d\u000aEverything `f_` offers will be used in the code example below. We will be using a class based approach (plain object not recommended). Since we will be initiating a lot of instances, so we will make use of JavaScript it's prototypal inheritance pattern.\u000d\u000a```js\u000d\u000a\u000d\u000a// EDIT THIS WITH NEW API / PROTO ASSIGMENT\u000d\u000a\u000d\u000avar f_ = require('f_');\u000d\u000a\u000d\u000a/** Class based TaskList.\u000d\u000a * All methods are written in this class\u000d\u000a * @class TaskList      Class which holds all methods, used to set data\u000d\u000a *                      on initialization\u000d\u000a * @arg o.url {string}  Url to grab source code from\u000d\u000a */\u000d\u000avar TaskList = function TaskList (o){\u000d\u000a  o = o || {};\u000d\u000a\u000d\u000a  return this;\u000d\u000a};\u000d\u000a\u000d\u000a/**\u000d\u000a * Create an empty namespace object to hold our proto(type) methods\u000d\u000a * Which will be assigned to the TaskList its prototype object\u000d\u000a */\u000d\u000avar proto = {};\u000d\u000a\u000d\u000a/**\u000d\u000a * @method start  Check if requirements are met\u000d\u000a */\u000d\u000aproto.start = function (){\u000d\u000a\u000d\u000a};\u000d\u000a\u000d\u000a\u000d\u000a/**\u000d\u000a * @method getSource          Gets a website source code\u000d\u000a * @req    url {string}  Url to grab source code from\u000d\u000a * @data   d.source {string}  Website it's source code\u000d\u000a */\u000d\u000aproto.getSource = function (){\u000d\u000a\u000d\u000a};\u000d\u000a\u000d\u000a\u000d\u000a/**\u000d\u000a * @method writeSource        Writes a source code on HD\u000d\u000a * @req    d.source {string}  Website it's source page\u000d\u000a */\u000d\u000aproto.writeSource = function (){\u000d\u000a\u000d\u000a};\u000d\u000a\u000d\u000a\u000d\u000a/**\u000d\u000a * @method notify  Log what happened in the previous methods\u000d\u000a */\u000d\u000aproto.notify = function (){\u000d\u000a\u000d\u000a};\u000d\u000a\u000d\u000a\u000d\u000a/**\u000d\u000a * Adding data to Class proto object, it will be same with every instance.\u000d\u000a * No need to add it to our shared data object namespace, which could be reset.\u000d\u000a * Also using the prototype object, we only assign it once.\u000d\u000a */\u000d\u000aproto.writeDir = './sourceCodes';\u000d\u000a\u000d\u000a\u000d\u000a/**\u000d\u000a * Assign methods from proto object to our TaskList its actual\u000d\u000a * prototype object.\u000d\u000a * Ofcourse, make sure our proto object has all properties we want it\u000d\u000a * to have before we assign it!\u000d\u000a */\u000d\u000aTaskList.prototype = proto;\u000d\u000a\u000d\u000a\u000d\u000a/** f_config object\u000d\u000a * In this object we can tell f_ what to do.\u000d\u000a * It can be quite detailed. But only a few properties are actualy\u000d\u000a * required for f_ to work\u000d\u000a */\u000d\u000avar f_config = {\u000d\u000a\u000d\u000a  // Function order f_ uses to call methods\u000d\u000a  // REQUIRED to atleast have one element!\u000d\u000a  functionFlow: ['getSource', 'writeSource', 'notify'],\u000d\u000a\u000d\u000a  // Name given to the errors array\u000d\u000a  // default: errs\u000d\u000a  errorArray: 'errs', \u000d\u000a\u000d\u000a  // Do we want a data reset when we use 'retryAll'. Can be changed later on\u000d\u000a  // in our code ofcourse!\u000d\u000a  // Default: false\u000d\u000a  resetOnRetryAll: true,\u000d\u000a\u000d\u000a  // Object in which we store our shared data.\u000d\u000a  // Default: 'd'\u000d\u000a  dataNamespace: 'd',\u000d\u000a\u000d\u000a  // Data namespace properties to keep on reset.\u000d\u000a  keepOnReset: ['testNamespace'],\u000d\u000a\u000d\u000a  // How many times f_ will retry the whole task list\u000d\u000a  // Default: 10\u000d\u000a  maxRetriesAll: 15,\u000d\u000a\u000d\u000a  // How many times f_ will retry a single method\u000d\u000a  // Default: 10\u000d\u000a  maxMethodRetries: 5,\u000d\u000a\u000d\u000a  // Specific methods will be retried specified times.\u000d\u000a  // Will override maxMethodRetries\u000d\u000a  maxMethodRetriesByName: {\u000d\u000a    getSource: 10,\u000d\u000a    writeSource: 5\u000d\u000a  },\u000d\u000a\u000d\u000a  // What to log\u000d\u000a  // start:   If first method in functionFlow is called\u000d\u000a  // next:    A method is called, we log the method name.\u000d\u000a  // retry:   A retry occurs, log everything known about it.\u000d\u000a  // error:   An error gets pushed to errs array, log err description and\u000d\u000a  //          origional error object.\u000d\u000a  // abort:   f_ aborts a task list, log error stack and method\u000d\u000a  //          which caused error.\u000d\u000a  // finish:  Log when tasks is complete and time taken\u000d\u000a  // all:     Log 'everything' f_ does, all above triggers will be true.\u000d\u000a  // silent:  Log nothing at all.\u000d\u000a  // Default: ['all']\u000d\u000a  toLog: ['next', 'retry']\u000d\u000a\u000d\u000a};\u000d\u000a\u000d\u000a// 'augment' method takes two arguments: object/class to augment and\u000d\u000a// a config object.\u000d\u000aTaskList = f_.augment(TaskList, f_config);\u000d\u000a\u000d\u000a// Initiate 100 instances \u000d\u000afor(var i = 0; i < 100; i+=1){\u000d\u000a  // Provide data which will be set to the instance it's properties.\u000d\u000a  var tasksInstance = new TaskList();\u000d\u000a  tasksInstance.start();\u000d\u000a\u000d\u000a  if(tasksInstance.errs.length === 0)\u000d\u000a    console.log('Ok, everything has started correctly, task:', i);\u000d\u000a  else\u000d\u000a    console.log('Errors at start, probably we do not want to continue w/', i);\u000d\u000a}\u000d\u000a```\u000d\u000a\u000d\u000a### In depth look at the way `f_` DOESN'T work.\u000d\u000a\u000d\u000aWhen we are looking at the way Node handles asynchronous computation, we are looking at the simple to grasp and understand, yet powerful practice of callbacks. Whilst this practice may be simple, code management, separation of concerns and loose coupling can be diffucult to achieve. This is due to something called 'callback hell'. Which will result in 'christmas tree code'. An (ugly) example below:\u000d\u000a```js\u000d\u000a/**\u000d\u000a * Simple task which will first GET google.com source code, write it to a HTML\u000d\u000a * file. When those two tasks are complete it will GET google.nl source code\u000d\u000a * and also write that to a HTML file. Written the most ugly way possible,\u000d\u000a * we're not even using named function declaration above the the async logic.\u000d\u000a */\u000d\u000ahttp.get('http://www.google.com', function (googleRes){\u000d\u000a  \u000d\u000a  var googleSource = '';\u000d\u000a  \u000d\u000a  googleRes.on('data', function (googleChunk){\u000d\u000a    googleSource = googleSource + googleChunk;\u000d\u000a  });\u000d\u000a  \u000d\u000a  googleRes.on('end', function (){\u000d\u000a    fs.writeFile('googleSource.html', googleSource, function (googleWriteErr){\u000d\u000a      if(googleWriteErr) return console.log(googleWriteErr);\u000d\u000a      \u000d\u000a      http.get('http://www.youtube.com', function (ytRes){\u000d\u000a        \u000d\u000a        var ytSource = '';\u000d\u000a        \u000d\u000a        ytRes.on('data', function (ytChunk){\u000d\u000a          ytSource = ytSource + ytChunk;\u000d\u000a        });\u000d\u000a        \u000d\u000a        ytRes.on('end', function (){\u000d\u000a          fs.writeFile('ytSource.html', ytSource, function (ytWriteErr){\u000d\u000a            if(ytWriteErr) return console.log(ytWriteErr);\u000d\u000a            \u000d\u000a            return console.log('Tasks complete!');\u000d\u000a          });\u000d\u000a        });\u000d\u000a      });\u000d\u000a    });\u000d\u000a  });\u000d\u000a});\u000d\u000a```\u000d\u000a\u000d\u000a\u000d\u000a\u000d\u000aAs you can see, this code hard to read, write and maintain. We're not even taking error handling and dependecy management in account here... Which will make it even harder to read, write and maintain.\u000d\u000a\u000d\u000a### In depth look at the way `f_` DOES work.\u000d\u000a\u000d\u000aLet's take a look at the way I want to write this simple task!\u000d\u000a\u000d\u000a```js\u000d\u000a/**\u000d\u000a * Please note we're still not using a good error handling mehtod,\u000d\u000a * the same logic as the ugly example is used.\u000d\u000a */\u000d\u000a\u000d\u000aproto.getGoogle = function (){\u000d\u000a  var self = this;\u000d\u000a\u000d\u000a  http.get('http://www.google.com', function (res){\u000d\u000a\u000d\u000a    var source = '';\u000d\u000a    res.on('data', function (chunk){ source = source + chunk; });\u000d\u000a\u000d\u000a    res.on('end', function (){\u000d\u000a      // Using the d object namespace to store data we\u000d\u000a      // need to use in other/later function scopes\u000d\u000a      self.d.googleSource = source;\u000d\u000a\u000d\u000a      // return statement isn't necessary, using it to show we're\u000d\u000a      // done with this task.\u000d\u000a      return self.next();\u000d\u000a    });\u000d\u000a\u000d\u000a  });\u000d\u000a};\u000d\u000a\u000d\u000a\u000d\u000aproto.writeGoogle = function (){\u000d\u000a  var self = this,\u000d\u000a      googleSource = self.d.googleSource;\u000d\u000a\u000d\u000a  fs.writeFile('googleSource.html', googleSource, function (err){\u000d\u000a    if(err) return console.log(err);\u000d\u000a    return self.next();\u000d\u000a  });\u000d\u000a\u000d\u000a};\u000d\u000a\u000d\u000aproto.getYt = function (){\u000d\u000a  var self = this;\u000d\u000a\u000d\u000a  http.get('http://www.youtube.com', function (res){\u000d\u000a\u000d\u000a    var source = '';\u000d\u000a    res.on('data', function (chunk){ source = source + chunk; });\u000d\u000a\u000d\u000a    res.on('end', function (){\u000d\u000a      self.d.ytSource = source;\u000d\u000a      return self.next();\u000d\u000a    });\u000d\u000a\u000d\u000a  });\u000d\u000a};\u000d\u000a\u000d\u000aproto.writeYt = function (){\u000d\u000a  var self = this,\u000d\u000a      ytSource = self.d.ytSource;\u000d\u000a\u000d\u000a  fs.writeFile('ytSource.html', ytSource, function (err){\u000d\u000a    if(err) return console.log(err);\u000d\u000a\u000d\u000a    // Using next when there are no more tasks will result in a low\u000d\u000a    // level f_ API 'f_.finish' method call. Clearing up used memory, etc..\u000d\u000a    return self.next();\u000d\u000a  });\u000d\u000a\u000d\u000a};\u000d\u000a```\u000d\u000a\u000d\u000aYes, we did it; separation of concerns and loose coupling! We could even modularize (litteraly) it, since all those smaller asynchronous tasks could be single modules, if wanted they can even be put in single files. In this case I would keep it in a single file, since all tasks are small and easy to read/maintain. Even though we are using more lines of code.\u000d\u000a\u000d\u000aSo far we can say that `f_` will allow us to program in a modularized way. Which is great already! Well, more greatness is coming your way!\u000d\u000a\u000d\u000aNow let's take a look at the way we will be handling errors (using a piece of the previous example):\u000d\u000a```js\u000d\u000a/**\u000d\u000a * In this piece of code, we will catch error messages so we can display\u000d\u000a * the complete error stack when the task is aborted, or when we look up\u000d\u000a * the f_ 'errs' array filled with error objects.\u000d\u000a */\u000d\u000aproto.getGoogle = function (){\u000d\u000a  var self = this;\u000d\u000a\u000d\u000a  http.get('http://www.google.com', function (res){\u000d\u000a\u000d\u000a    var source = '';\u000d\u000a    res.on('data', function (chunk){ source = source + chunk; });\u000d\u000a\u000d\u000a    res.on('end', function (){\u000d\u000a      self.d.googleSource = source;\u000d\u000a      return self.next();\u000d\u000a    });\u000d\u000a\u000d\u000a  }).on('error', function (err){\u000d\u000a    // We provide a custom error message string and the original err object\u000d\u000a    return self.addErr('http.get error', err);\u000d\u000a  });\u000d\u000a};\u000d\u000a\u000d\u000a\u000d\u000aproto.writeGoogle = function (){\u000d\u000a  var self = this,\u000d\u000a      googleSource = self.d.googleSource;\u000d\u000a\u000d\u000a  fs.writeFile('googleSource.html', googleSource, function (err){\u000d\u000a    // Same as with http.get\u000d\u000a    if(err) return self.addErr('fs.writeFile error', err);\u000d\u000a\u000d\u000a    return self.next();\u000d\u000a  });\u000d\u000a\u000d\u000a};\u000d\u000a```\u000d\u000a\u000d\u000aSo we've got a way to create an error stack, now we need a way to do something when an error occurs. This could ofcourse be done traditionally with \u000d\u000a`on('error')` event listeners. The problem with that is, we cannot directly 'throw' in a retry when something fails. Writing `on('error')` listeners everytime is tedious. Something we try to remove from programming Node programs (don't forget you CAN still use them!). So with `f_` we can do it directly from a piece of code that causes an error. Take a look at this example:\u000d\u000a```js\u000d\u000a// Immediately retry this asynchronous part of a larger task list\u000d\u000aproto.getGoogle = function (){\u000d\u000a  var self = this;\u000d\u000a\u000d\u000a  http.get('http://www.google.com', function (res){\u000d\u000a    // ...\u000d\u000a  }).on('error', function (err){\u000d\u000a    // With this function call we still add errors to the stack,\u000d\u000a    // but immediately retry the current function\u000d\u000a    return self.retryThis('http.get error', err);\u000d\u000a  });\u000d\u000a};\u000d\u000a```\u000d\u000a\u000d\u000aLet's say we use the source code received from Google.com in a later function but the `GET` request fails the first time, we want to make sure every piece of data we stored is removed from our RAM. We need a way to make `f_` know what data to remove from the data namespace object. We can do this by manualy providing `f_` with objects.\u000d\u000a\u000d\u000a```js\u000d\u000aproto.getGoogle = function (){\u000d\u000a  var self = this;\u000d\u000a\u000d\u000a  http.get('http://www.google.com', function (res){\u000d\u000a    self.d.googleSource = '';\u000d\u000a    res.on('data', function (chunk){\u000d\u000a      self.d.googleSource = self.d.googleSource + chunk;\u000d\u000a    });\u000d\u000a\u000d\u000a    res.on('end', function (){\u000d\u000a      return self.next();\u000d\u000a    });\u000d\u000a\u000d\u000a  }).on('error', function (err){\u000d\u000a    // Providing 'dataToReset' with an object, f_ will reset properties\u000d\u000a    // with given values when we use the retryThis method\u000d\u000a    self.dataToReset = { googleSource: '' };\u000d\u000a\u000d\u000a    // The following syntax is also supported, this way we can reset\u000d\u000a    // objects deeper in the data namespace object\u000d\u000a    self.dataToReset = { 'dataObjectNamespace.someProperty': {} }\u000d\u000a\u000d\u000a    return self.retryThis('http.get error', err);\u000d\u000a  });\u000d\u000a};\u000d\u000a```\u000d\u000a\u000d\u000aThis way we can ensure data is removed, ofcourse you could also override properties. But this could result in unwanted and hard to find corrupted data. There also is way to make sure EVERY piece of data is removed from our data object namespace: `self.resetAllData();`\u000d\u000a\u000d\u000aSo far we've talked about the data object namespace quite a lot. Let's take a closer look at how it works. We used the `d` namespace in our examples. This is just a plain JS object. With `f_` we can set our data object like this: `self.setDataObject('d')` or like this: `self.d = {};`. If you want more namespaces, simply do the following:\u000d\u000a`self.d.newNameSpace = {}`. \u000d\u000aPlease note that when you use the `self.resetAllData();` all namespaces in the top level namespace will be cleared. In case this is unwanted there is a way to let `f_` know we want to keep certain properties in our main namespace: \u000d\u000a`self.keepOnReset = ['newNameSpace'];`. There might even be cases where you don't want to reset anything at all, use: `self.resetOnRetry = false;`\u000d\u000a\u000d\u000a\u000d\u000a* DISCUSS: `retryAll(optErrMsgString, optErrObj);`\u000d\u000a* DISCUSS: `retryThis(optErrMsgString, optErrObj);`\u000d\u000a\u000d\u000a\u000d\u000a\u000d\u000aLet's put everything in a part of a 'real world' code example:\u000d\u000a```js\u000d\u000a/**\u000d\u000a * When using f_, I tend to use 'start' as a function which will check\u000d\u000a * for dependencies and as a setup.\u000d\u000a */\u000d\u000aproto.start = function (){\u000d\u000a  // ... dependency verification could/should be here ...\u000d\u000a\u000d\u000a  self.setDataObject('d');\u000d\u000a  // ^ Could also be written like this: self.d = {};\u000d\u000a  // might result in overriding data, since setDataObject won't\u000d\u000a  // change the property if it's set already\u000d\u000a\u000d\u000a  self.d.newNameSpace = {};       // this one will be kept\u000d\u000a  self.d.someOtherNamespace = {}; // this one will be removed\u000d\u000a\u000d\u000a  // Which properties to keep when we use a reset\u000d\u000a  self.keepOnReset = ['newNameSpace'];\u000d\u000a\u000d\u000a  // Do we actualy want a data reset? In this case; true!\u000d\u000a  self.resetOnRetry = true;\u000d\u000a\u000d\u000a};\u000d\u000a\u000d\u000aproto.getGoogle = function (){\u000d\u000a  var self = this;\u000d\u000a\u000d\u000a  self.d.googleSource = '';\u000d\u000a  res.on('data', function (chunk){\u000d\u000a    self.d.googleSource = self.d.googleSource + chunk;\u000d\u000a  });\u000d\u000a\u000d\u000a  res.on('end', function (){\u000d\u000a    return self.next();\u000d\u000a  }).on('error', function (err){\u000d\u000a    // With this function call we still add errors to the stack,\u000d\u000a    // but immediately retry the current function\u000d\u000a    return self.retryThis('http.get error', err);\u000d\u000a  });\u000d\u000a\u000d\u000a};\u000d\u000a\u000d\u000aproto.writeGoogle = function (){\u000d\u000a  // Check if the required data is present. In case it isn't,\u000d\u000a  // we retry our whole task list\u000d\u000a};\u000d\u000a\u000d\u000a```","gitHead":"e7f22220a1d44986c8538faab63d2a2f6ab72296","_id":"f_@0.0.6","_shasum":"376abcfea4af50c0be1b8a443c8103024c062be0","_from":".","_npmVersion":"1.4.27","_npmUser":{"name":"opensoars","email":"sam.dev@outlook.com"},"maintainers":[{"name":"opensoars","email":"sam.dev@outlook.com"}],"dist":{"shasum":"376abcfea4af50c0be1b8a443c8103024c062be0","tarball":"http://registry.npmjs.org/f_/-/f_-0.0.6.tgz"}}: f_
42 error     at RegClient.<anonymous> (C:\Program Files\nodejs\node_modules\npm\node_modules\npm-registry-client\lib\request.js:308:14)
42 error     at Request._callback (C:\Program Files\nodejs\node_modules\npm\node_modules\npm-registry-client\lib\request.js:246:65)
42 error     at Request.self.callback (C:\Program Files\nodejs\node_modules\npm\node_modules\request\request.js:236:22)
42 error     at Request.EventEmitter.emit (events.js:98:17)
42 error     at Request.<anonymous> (C:\Program Files\nodejs\node_modules\npm\node_modules\request\request.js:1142:14)
42 error     at Request.EventEmitter.emit (events.js:117:20)
42 error     at IncomingMessage.<anonymous> (C:\Program Files\nodejs\node_modules\npm\node_modules\request\request.js:1096:12)
42 error     at IncomingMessage.EventEmitter.emit (events.js:117:20)
42 error     at _stream_readable.js:920:16
42 error     at process._tickCallback (node.js:415:13)
43 error If you need help, you may report this *entire* log,
43 error including the npm and node versions, at:
43 error     <http://github.com/npm/npm/issues>
44 error System Windows_NT 6.1.7601
45 error command "C:\\Program Files\\nodejs\\\\node.exe" "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js" "publish"
46 error cwd C:\dev\f_
47 error node -v v0.10.17
48 error npm -v 1.4.27
49 verbose exit [ 1, true ]
